const Error = require('verror');
const objectPath = require('object-path');

/**
 * Application error formatter
 *
 * @description Formats application errors according to type
 * @function
 * @param {Object} error - Express.js err
 * @returns {Object} - Formatted error object to be passed to local-logger
 */
function appError(error) {
  const statusCode = objectPath.get(error.jse_info, 'statusCode', 500);
  const statusText = objectPath.get(error.jse_info, 'statusText', 'fail');
  const validationErrors = objectPath.get(error.jse_info, 'data');

  const jsonResponse = () => {
    // Check for a statusCode NOT 4xx or 404 specifically
    if (!statusCode.toString().startsWith('4') || statusCode.toString() === '404') {
      return {
        status: statusText,
        message: error.message,
        code: error.name,
        data: [],
      };
    }

    return {
      status: statusText,
      code: error.name,
      data: (() => {
        const obj = {};

        Object.keys(validationErrors).forEach((key) => {
          obj[key] = validationErrors[key];
        });

        return obj;
      })(),
    };
  };

  return new Error({
    name: error.name,
    info: {
      statusCode,
      statusText,
      jsonResponse,
      stackTrace: error.stack,
    },
  }, error.message);
}

/**
 * Sequelize ORM error formatter
 *
 * @description Formats Sequelize ORM errors according to type
 * @function
 * @param {Object} error - Express.js err
 * @returns {Object} - Formatted error object to be passed to local-logger
 */
function sequelizeError(error) {
  const statusCode = (error.errors && error.errors.length) ? 400 : 500;
  const statusText = (error.errors && error.errors.length) ? 'fail' : 'error';

  const jsonResponse = () => {
    if (statusCode !== 400) {
      return {
        status: statusText,
        message: error.message,
        code: error.name,
        data: [],
      };
    }

    return {
      status: statusText,
      code: error.name,
      data: (() => {
        const obj = {};

        error.errors.forEach((e) => {
          obj[e.path] = e.message;
        });

        return obj;
      })(),
    };
  };

  return new Error({
    name: error.name,
    info: {
      statusCode,
      statusText,
      jsonResponse,
      stackTrace: error.stack,
    },
  }, error.message);
}

/**
 * JSON Web Token (JWT) error formatter
 *
 * @description Formats JWT errors according to type
 * @function
 * @param {Object} error - Express.js err
 * @returns {Object} - Formatted error object to be passed to local-logger
 */
function jwtError(error) {
  const statusCode = 401;
  const statusText = 'fail';

  const jsonResponse = () => ({
    status: statusText,
    code: error.name,
    data: { jwt: error.message },
  });

  return new Error({
    name: error.name,
    info: {
      statusCode,
      statusText,
      jsonResponse,
      expiredAt: error.expiredAt,
      stackTrace: error.stack,
    },
  }, error.message);
}

/**
 * Determines which error formatter should be used
 *
 * @description Switch statement between error formatters
 * @function
 * @param {Object} error - Express.js err
 * @returns {Object} - Formatted error object to be passed to local-logger
 */
function determineError(error) {
  const errorName = error.name;

  switch (true) {
    case (errorName.includes('Sequelize')):
      return sequelizeError(error);
    case (errorName.includes('TokenExpiredError') || errorName.includes('JsonWebTokenError')):
      return jwtError(error);
    default:
      return appError(error);
  }
}

module.exports = determineError;
